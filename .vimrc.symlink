let mapleader=','
filetype plugin on
filetype indent on

" highlight search by default 
set hls

" Ignore these extensions when file-completing 
set wildignore=*.o,*.obj,*.tar.gz,*.tgz,*.zip,*.pdf,*.sl,*.so,*.r,*.git,*.png,*.jpg,*.svg,*.doc,*.gif,*.class,*.exe,*.sw?,*.py?,*.orig,*.aux,*.toc,*.out

" enable file detection
filetype on 

syntax on 

" matching (, [, { /* ... etc
set showmatch 
set mat=1 " how many tens of second to blink 

" show the current filename and path in the term title
set title

" Write the contents of the file, if it has been modified, on each
" :next, :rewind, :last, :first, :previous, :stop, :suspend, :!, :make .. etc
set autowrite

set wrap " Wrapline

" show the current filename and path in the term title
set title

" searching starts as soon as you start typing the first letter of the word
set incsearch

syntax enable
" set background=default

" Indentation configuration
" 4 spaces, no tab, spaces
set tabstop=4 shiftwidth=4 expandtab
" 8 spaces, no tab, spaces
" set tabstop=8 shiftwidth=8 expandtab

set ai " Autoindent
set si " Smartindent

" display line numbers
set number

" Commenting/Uncommenting blocks of code for different file types
" souce: http://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim#comment27973419_1676672
autocmd FileType c,cpp,java,scala 	          let b:comment_leader = '// '
autocmd FileType sh,ruby,python   	          let b:comment_leader = '# '
autocmd FileType conf,fstab,make,cfg       	  let b:comment_leader = '# '
autocmd FileType tex              	          let b:comment_leader = '% '
autocmd FileType mail             	          let b:comment_leader = '> '
autocmd FileType vim               	          let b:comment_leader = '" '
autocmd FileType sql			          let b:comment_leader = '-- '
noremap <silent> <leader>cc :<C-B>silent <C-E>s/^/<C-R>=escape(b:comment_leader,'\/')<CR>/<CR>:nohlsearch<CR>
noremap <silent> <leader>cu :<C-B>silent <C-E>s/^\V<C-R>=escape(b:comment_leader,'\/')<CR>//e<CR>:nohlsearch<CR>

" Map <F6> to swap a comment and the following uncommented line, and vice versa
map <expr> <F6> (getline('.') =~ b:comment_leader . "*")? ',cuj,cck' : ',ccj,cuk'

" Save a file as root (,W)
noremap <leader>W :w !sudo tee % > /dev/null<CR>

" '\s' to paste a simple cpp header
" 'F5' to compile the actual cpp file, vsplit the window and output the errors
" 'F10' to close
" source: goo.gl/6BJUhU
" nmap \s i#include<iostream><Esc>ousing namespace std;<Esc>o
" nmap <F5> :w<CR>:silent !g++ % 2> ~/errors<CR>:redraw!<CR>:rightbelow vsplit ~/errors<CR><C-w>k
" nmap <F10> :bdelete ~/errors<CR>

"  rot13 encoding when pressing F3, again to decrypt
map <F3> ggvGg?

nmap <F5> :w<CR>:silent !python % 2> ~/errors<CR>:redraw!<CR>:rightbelow vsplit ~/errors<CR><C-w>k
nmap <F10> :bdelete ~/errors<CR>

" automaticly closing { brace
inoremap {<CR> {<CR>}<C-o>O

" map nivgation between windows to Alt + <ArrowKey>
" source: vim.wikia.com/wiki/Switch_between_Vim_window_splits_easily
nmap <silent> <A-Up> :wincmd k<CR>
nmap <silent> <A-Down> :wincmd j<CR>
nmap <silent> <A-Left> :wincmd h<CR>
nmap <silent> <A-Right> :wincmd l<CR>

colorscheme default

" default the statusline to green when entering Vim
hi statusline guibg=DarkGrey ctermfg=8 guifg=White ctermbg=15
set statusline=%F                           " file name
" set statusline+=\ \ [%{strlen(&fenc)?&fenc,:''} "file encoding
set statusline+=\ \ [%{&ff}] "file format
set statusline+=%y      "filetype
set statusline+=%h      "help file flag
set statusline+=%m      "modified flag
set statusline+=%r      "read only flag
set statusline+=\ %=                        " align left
set statusline+=
set statusline+=Line:%l/%L[%p%%]            " line X of Y [percent of file]
set statusline+=\ Col:%c                    " current column
set statusline+=\ [0x%B]\               " ASCII and byte code under cursor
set laststatus=2

iabbrev dispaly display
iabbrev adn and
iabbrev nad and
iabbrev teh the
iabbrev het the
iabbrev ehty they
iabbrev hety they
iabbrev tehn then
iabbrev waht what
iabbrev THen Then
iabbrev THe The
iabbrev ANd And
iabbrev WHen When
iabbrev HOw How
iabbrev WHy Why
iabbrev THis This
iabbrev thsi this
iabbrev Thsi This
iabbrev THere There
iabbrev THey They
iabbrev RIce Rice
iabbrev countires countries
iabbrev governmetn government
iabbrev minumum minimum
iabbrev dependece dependence
iabbrev smae same
iabbrev THus Thus
iabbrev SLECT SELECT
iabbrev SELCT SELECT
iabbrev pakcage package
iabbrev	impotr import
iabbrev retunr return
iabbrev catiexp Centre Aquitain des Technologies de l'Information et Electroniques
iabbrev Catiexp Centre Aquitain des Technologies de l'Information et Electroniques

" Java abreviation for System.out.println
iabbr sysout System.out.println("");<esc>2hi

" Source the vimrc file after saving it
autocmd BufWritePost $MYVIMRC source $MYVIMRC

" force *.md files as markdown
autocmd BufNewFile,BufReadPost,BufRead *.md,*.markdown set filetype=markdown

" force bash_* config files as shell
autocmd BufNewFile,BufReadPost,BufRead .bash_* set filetype=sh

set undofile
set undodir=~/.vim/undodir

" ??
let g:ctags_path="~/.vim/plugin"
let g:ctags_statusline=1

" Adapted from Damian Conway's vimrc file: https://github.com/thoughtstream/Damian-Conway-s-Vim-Setup/blob/master/.vimrc
" ====[ Show when lines extend past column 80]=================================>-<=====================
highlight ColorColumn ctermfg=208 ctermbg=Black
function! MarkMargin (on)
	" Black list: Don't put the 80 column marker for these filetypes, 
	" no more used, manually toggled when needed ;)
	" if &ft =~ 'tex\|markdown\|vim'
	" 	return 
	" endif
	if exists('b:MarkMargin')
		try
			call matchdelete(b:MarkMargin)
		catch /./
		endtry
		unlet b:MarkMargin
	endif
	if a:on
		let b:MarkMargin = matchadd('ColorColumn', '\%80v\s*\S', 100)
	endif
endfunction
augroup MarkMargin
	autocmd!
	autocmd  BufEnter  *       :call MarkMargin(1)
	autocmd  BufEnter  *.vp*   :call MarkMargin(0)
augroup END

" manually toggle margin for the current script
let s:mode = 0
function! ToggleMargin()
	let s:mode = s:mode > 0 ? 0 : 1
	call MarkMargin(s:mode)
 	echo s:mode > 0 ? "Margin on" : "Margin off"
endfunction

" map F8 to toggle margin
nmap <silent> <F8> :call ToggleMargin()<CR>
imap <silent> <F8> <ESC>:call ToggleMargin()<CR>a
"===============================>-<=====================

" Load local .vimrc, if existing
set exrc

" TeX quick mappings
" inoremap <C-i> \emph{}<esc>i 
inoremap <C-b> \textbf{}<esc>i
inoremap <C-u> \underline{}<esc>i

" Custom colorscheme for LaTeX files
" autocmd BufEnter *.tex colorscheme slate

" Return to the same line when you re-open a file, credits to Steve Losh (to Amit, in fact)
augroup line_return
	au!
	au BufReadPost *
				\ if line("'\"") > 0 && line("'\"") <= line("$") |
				\     execute 'normal! g`"zvzz' |
				\ endif
augroup END

" mapping to fast-make and redraw (useful in TeX projects), credits to https://stackoverflow.com/a/11590512
nnoremap <leader>mm :silent make\|redraw!\|cc <CR>

" map ,sc to 'source code quote' the current word/expression
" Known pitfalls: words containing dots
autocmd FileType markdown nnoremap <leader>sc ciw``<Esc>P
autocmd FileType markdown xnoremap <leader>sc c``<Esc>P

" map Ctrl-S to save the file in insert mode
imap <C-S> <ESC>:w<CR>a
" Consequently... (see https://vi.stackexchange.com/a/2425)
silent !stty -ixon
" Restore default behaviour when leaving Vim
autocmd VimLeave * silent !ssty ixon

" show current function name (useful in C/C++ programs), credits to https://stackoverflow.com/a/23259759
" /!\ fails in the following cases:
"  * function name in more than one line
fun! ShowFuncName()
	let lnum = line(".")
	let col = col(".")
	echohl ModeMsg
	echo getline(search("^[^ \t#/]\\{2}.*[^:]\s*$", 'bW'))
	echohl None
	call search("\\%" . lnum . "l" . "\\%" . col . "c")
endfun
autocmd FileType c,cpp nnoremap <leader>f :call ShowFuncName() <CR>

" map ,mb to 'mbed compile' the current project
nnoremap <leader>mb :!mbed compile -c <CR>

nnoremap <F7> :noh<CR>
