# .bash_functions

whattimeisit(){
	m=$(date +%M)
	h=$(date +%H)
	if [ "$h" -eq 0 ]; then
		hour="midnight"
	fi
	if [ "$m" -eq 15 ]; then
		current_time="It's quarter past $h"
	elif [ "$m" -eq 30 ]; then
		current_time="It's half past $h"
	elif [ "$m" -eq 45 ]; then
		current_time="It's quarter to $(($h + 1))"
	else 
		current_time="It's $m past $h"
	fi
	echo "$current_time"| espeak 
}

espanol(){
	if [ "$#" -eq 0 ]; then
		more ~/espanol.txt
	else 
		#Â test if the word is not previously defined
		if ! grep -q "^$1" ~/espanol.txt ; then 
			echo "$1: ${@:2}" >> ~/espanol.txt
		else 
			grep "^$1" ~/espanol.txt --color=auto
		fi
	fi
}

# git pull in all existing (found) repositories
pull_all(){
	wc=$(pwd)
	repos=(`find ~ -name '*.git'`)
	for repo in "${repos[@]}"; do
		repo=$(echo "$repo"| sed -e 's/\.git//g')
		printf "\033[00;32m$repo\033[0m ... "
		cd && cd "$repo" && git pull 2> /dev/null|grep -v "Already up-to-date"
		if [ "$?" -ne 0 ]; then
			echo ""
		fi
	done
	cd "$wd"
}

klit(){
	if [ "$#" -eq 0 ]; then
		sed '1!G;h;$!d' ~/.achkliti |more
	else 
		echo "[$(date| sed -e 's/ (.*//g')] $@" >> ~/.achkliti
	fi
}

purge(){
	rm -rfv "$1"
}

backitup(){
	cd ~
	backup_time=$(date +%d%B%y)
	if [ -f ".backups/backup_$backup_time.tar.gz" ]; then
		rm -f ".backups/$backup_time.tar.gz"
	fi
	tar -zcf ".backups/backup_$backup_time.tar.gz" $(ls ~) >>/dev/null 2>&1 && dropbox_uploader.sh upload ".backups/backup_$backup_time.tar.gz" debian_backups && alert "Backup ended successfully."
}

# Swap two file names: $1 and $2
swap(){
	mv "$1" "$1_tmp"
	mv "$2" "$1"
	mv "$1_tmp" "$2"
}

# Find the max of a list of integers
# $1, ..., $n integers
max(){
	for number in "$@"; do echo "$number"; done| sort -nr| head -n 1
}

# Find the min of a list of integers
# $1, ..., $n integers
min(){
	for number in "$@"; do echo "$number"; done| sort -n| head -n 1
}

# automatic 'git push'
# Requires access without password to the repository.
# When provided, $1 contains the path to the local git repository.
# Otherwise, cwd is used.
autopush(){
	[[ "$#" -eq 1 ]] && cd "$1"
	if [[ ! -d '.git' ]] && [[ ! -d '../.git' ]]; then
		echo "$(tput bold)$(pwd)$(tput sgr0) is not a git directory." && return 1
	fi

	[[ "$#" -eq 2 ]] && commit_message="$2" ||\
	commit_message="[autopush] $(date "+%d %B %y - %H:%M")"
	git config user.email "nabilelqatib@gmail.com" ; git config user.name "marrakchino" 
	git commit -a -m "${commit_message}" && git push --quiet
	[[ "$?" -eq 0 ]] && echo "autopush done successfully."
	[[ "$#" -eq 1 ]] && cd -
}

# automatic remote pull
autopull(){
	[[ "$#" -eq 1 ]] && cd "$1"
	if [[ ! -d '.git' ]] && [[ ! -d '../.git' ]]; then
		echo "$(tput bold)$(pwd)$(tput sgr0) is not a git directory." && return 1
	fi

	git pull
	[[ "$?" -eq 0 ]] && echo "autopull done successfully."
	[[ "$#" -eq 1 ]] && cd -
}

findx(){
	find . -name "*.$1"
}

# Which branch?
# Check which branch a repository is in without moving to it.
wb(){
	cd "$1" || return 1
	echo "$(tput bold)$(git branch 2> /dev/null | sed -e '/^[^*]/d' )$(tput sgr0)"
	cd -
}

# Find and go to (or parent directory if argument is not a directory) 
# $1: name of the directory/file to go to 
goto(){
    # use find to get results, excluce hidden files/directories
    results=( $(find . -iname "${1}" -not -path '*/\.*' ) )

    # cd to parent directory if it's not a directory
    change_directory(){
        if [[ -d "${1}" ]]; then
            cd "${1}"
        else 
            cd $(dirname "${1}")
        fi
    }

    # only one result found
    if [[ ${#results[@]} -eq 1 ]]; then
        change_directory "${results[0]}"

    elif [[ "${#results[@]}" -ne 0 ]]; then
        for i in $(seq 0 $((${#results[@]} - 1))); do
            echo "${i}: ${results[${i}]}"
        done
        read  -p "Your choice: " choice
        if [[ "$choice" -lt ${#results[@]} ]] && [[ "$choice" -ge 0 ]]; then
            # cd to parent directory if it's not a directory
            change_directory "${results[${choice}]}"
        else
            echo "Invalid choice."
        fi
    else
        echo "No directory/file found."
    fi
}
